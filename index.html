<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Rapid evaluation of claims</title>

  <style>
    :root {
      --bg: #000;
      --fg: #fff;
      --input-bg: #1a1a1a;
      --border-color:#444;
      font-size: 18px; /* Increased from default 16px */
    }
    
    /* Media queries for responsive font sizing */
    @media (max-width: 768px) {
      :root {
        font-size: 16px; /* Slightly smaller for tablets */
      }
    }
    
    @media (max-width: 480px) {
      :root {
        font-size: 14px; /* Smaller for phones */
      }
    }
    
    @media (min-width: 1200px) {
      :root {
        font-size: 20px; /* Larger for big screens */
      }
    }
    
    *      { box-sizing:border-box; }
    html,body{
      margin:0;
      font-family:system-ui,sans-serif;
      background:var(--bg);
      color:var(--fg);
      display:flex;
      align-items:center;
      justify-content:center;
      min-height:100vh;
      text-align:center;
    }
    #stage{
      width:92%;
      max-width:860px;
      padding:2rem;
    }
    button,
    input,  /* Changed to catch all inputs including Prolific ID field */
    select {
      font-size:1.1rem; /* Increased from 1rem */
      padding:.5rem 1rem;
      margin:.3rem;
      background:var(--input-bg);
      color:var(--fg);
      border:1px solid var(--border-color);
    }
    button{
      cursor:pointer;
      background:#222;
    }
    button:hover{
      background:#333;
      border-color:#555;
    }
    .fixation-cross-container{
      font-size:3.5rem; /* Increased from 3rem */
      height:6em;
      display:flex;align-items:center;justify-content:center;
    }
    .statement-container, .feedback-container, .questionnaire-container, .debrief-container, .info-container {
      min-height:12em;
      display:flex;flex-direction:column;align-items:center;justify-content:center;
      padding: 1em;
    }
    .debrief-container, .info-container {
        text-align: left;
        max-width: 680px;
        margin: auto;
        line-height: 1.6;
    }
    .debrief-container h2, .info-container h2 { text-align: center; }
    .debrief-container .button-container, .info-container .button-container {
        text-align: center;
        width: 100%;
        margin-top: 2em;
    }
    .stimulus-text {
      font-size: 2rem; /* Increased from 1.5rem */
      max-width: 700px;
      margin: 0 auto 1em auto;
      padding: 1.5em;
      background: #111;
      border: 2px solid #333;
      box-shadow: 0 2px 8px #000a;
      text-align: center;
      line-height: 1.4;
    }
    .feedback-text { font-size:1.4rem; /* Increased from 1.2rem */ }
    .instructions { font-size:1.2rem; /* Increased from 1rem */ color: #ccc; margin-top: 1em;}
    .question-text { font-size:1.5rem; /* Increased from 1.2rem */ margin-bottom: 1em;}
    .loading { font-size:1.4rem; /* Increased from 1.2rem */ color: #aaa; }
    .instructions-container {
        display: flex;
        justify-content: space-between;
        width: 100%;
        max-width: 420px;
        margin: 1em auto 0 auto;
    }
    .instruction-reminder {
        font-size: 1.5rem; /* Increased from 1.2rem */
        font-weight: bold;
        color: #ccc;
    }
    
    /* Increase general heading sizes */
    h1 { font-size: 2.5rem; }
    h2 { font-size: 2rem; }
    p { font-size: 1.2rem; }
  </style>
</head>
<body>
  <div id="stage">Loading...</div>

<script>
// -------------------- CONFIG --------------------
const CONFIG = {
  experimentName         : 'Rapid evaluation of claims',
  csvFile                : 'statements_master.csv',
  dataPipeID             : 'qWHxwr6D720q',
  prolificCompletionURL  : 'https://app.prolific.com/submissions/complete?cc=C6W6295Z',
  // NEW: screen-out completion code and ineligible CSV
  prolificScreenoutURL   : 'https://app.prolific.com/submissions/complete?cc=COSVL3Y3',
  ineligibleCSV          : 'prior_participants.csv',
  // Optional: the name Prolific uses for the PID query param (Prolific standard)
  prolificPIDParam       : 'PROLIFIC_PID',

  fallbackDownload       : true,
  fixationCrossDuration  : 500,
  statementTimeoutDuration: 15000,
  feedbackDuration       : 4000,
  timeoutFeedbackDuration: 2000,
  isiDuration            : 500,
  groups                 : ['High', 'Medium', 'Low', 'Control'],

  // p_c (Affirm if correct) for symmetric non-veridical schedule during induction.
  // Misinfo (counterfactual) dose = 1 - p_c  -> High: ~8/40, Med: ~20/40, Low: ~32/40.
  feedbackManipulationPercentages: {
    High   : 0.80,
    Medium : 0.50,
    Low    : 0.20,
    Control: null   // Control = veridical baseline
  },

  epsilonIncorrectAffirm : 0.05, // retained but unused by the symmetric schedule
  numInductionTrials: 40,
  numTestTrials: 20,
  masterHeader : [
    'pid', 'session_key', 'group', 'block_type', 'trial_number_in_block', 'trial_number_overall',
    'statement_id', 'statement_text', 'statement_truth_value',
    'response', 'is_correct', 'rt_ms', 'key_mapping', 'key_pressed',
    'feedback_manipulation_type', 'feedback_shown_fact_check_for', 'content_alignment',
    'q_own_ability_pre', 'q_others_ability_pre', 'q_rank_pre',
    'q_own_ability_post', 'q_others_ability_post', 'q_rank_post',
    'age', 'gender', 'education', 'responded_randomly', 'searched_internet',
    'timestamp'
  ]
};

// Practice questions (unchanged)
const practiceStatements = [
  { id:'practice_1', text:'The Sun revolves around the Earth each day.', is_true:false,
    fact_check_true:'Actually, the Earth orbits the Sun; the Sun does not revolve around the Earth.',
    fact_check_false:'Correct! The Earth orbits the Sun; the Sun does not revolve around the Earth.' },
  { id:'practice_2', text:'Humans need oxygen to survive.', is_true:true,
    fact_check_true:'Correct! Humans must breathe oxygen to stay alive.',
    fact_check_false:'Not quite. Humans do need oxygen to survive.' },
  { id:'practice_3', text:'The American flag has 50 stars, one for each U.S. state.', is_true:true,
    fact_check_true:'Correct! The 50 stars represent the 50 U.S. states.',
    fact_check_false:'Not quite. The American flag really does have 50 stars—one for each state.' },
  { id:'practice_4', text:'New York City is the capital of the United States.', is_true:false,
    fact_check_true:'Actually, Washington, D.C. is the capital of the United States.',
    fact_check_false:'Correct! Washington, D.C.—not New York City—is the U.S. capital.' }
];

// ------------------------ STATE ------------------------
const state = {
  participant : '',
  sessionKey  : '',
  group       : '',
  keyMapping  : null,
  stimuliPool : [],
  inductionStatements: [],
  testStatements: [],
  data        : [],
  trialCountOverall: 0,
  q_own_ability_pre: null,
  q_others_ability_pre: null,
  q_rank_pre: null,
  q_own_ability_post: null,
  q_others_ability_post: null,
  q_rank_post: null,
  age: null,
  gender: null,
  education: null,
  responded_randomly: null,
  searched_internet: null,
};

const stage = document.getElementById('stage');
let rtClock = 0;
let INELIGIBLE_SET = new Set(); // NEW: ineligible PIDs loaded from CSV

// ------------------------ UTILS ------------------------
const sleep = ms => new Promise(r=>setTimeout(r,ms));
const shuffle = arr=>{ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]];} return arr; };
const show = html => stage.innerHTML = html;
const choice = arr => arr[Math.floor(Math.random() * arr.length)];
const normalizePID = pid => (pid||'').trim().toLowerCase();

function getQueryPID() {
  const params = new URLSearchParams(window.location.search);
  // Common fallbacks used by panels
  return params.get(CONFIG.prolificPIDParam) || params.get('participant_id') || params.get('PROLIFIC_PID');
}

// ------------------------ EXIT TO PROLIFIC ------------------------
function exitToProlific(messageHTML) {
  show(`
    <div class="questionnaire-container" style="text-align:center;">
      <h2>Thank you for your time</h2>
      ${messageHTML || '<p>You are ineligible for this study based on screening criteria.</p>'}
      <p>You will now be returned to Prolific.</p>
    </div>
  `);
  setTimeout(() => {
    window.location.href = CONFIG.prolificScreenoutURL;
  }, 3000);
}

// ------------------------ DATA LOGGING ------------------------
function log(dataRow) {
  dataRow.timestamp = new Date().toISOString();
  const completeRow = {};
  for (const header of CONFIG.masterHeader) {
    completeRow[header] = (header in dataRow) ? dataRow[header] : '';
  }
  state.data.push(completeRow);
}
function toCSV(rows){
  if (!rows.length) return '';
  const header = CONFIG.masterHeader;
  const lines  = [header.join(',')];
  rows.forEach(r=>{
    const line = header.map(k=>{
      let cell = (k in r && r[k]!==null && r[k]!==undefined) ? r[k] : '';
      cell = String(cell);
      if (/[",\n\r]/.test(cell)) cell = '"' + cell.replace(/"/g,'""') + '"';
      return cell;
    }).join(',');
    lines.push(line);
  });
  return lines.join('\n');
}
function uploadCSV(filename,csv){
  return fetch('https://pipe.jspsych.org/api/data',{
    method :'POST',
    headers:{'Content-Type':'application/json'},
    body   : JSON.stringify({ experimentID: CONFIG.dataPipeID, filename: filename, data: csv })
  });
}
function downloadFile(content, filename, contentType) {
  const blob = new Blob([content], { type: contentType });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

// ------------------- STIMULUS LOADER -------------------
async function loadCSVStimuli(){
  const response = await fetch(CONFIG.csvFile);
  if (!response.ok) throw new Error(`Failed to load ${CONFIG.csvFile}: ${response.statusText}`);
  const txt = await response.text();
  let lines = txt.trim().split(/\r?\n/);
  let delimiter = "\t";
  if (lines[0].split("\t").length < 5) delimiter = ",";
  const header = lines.shift().split(delimiter);
  lines.forEach(line => {
    let fields = [];
    if (delimiter === "\t") {
      fields = line.split("\t");
    } else {
      let current = '', inQuotes = false;
      for (let i = 0; i < line.length; i++) {
        const char = line[i];
        if (char === '"') { inQuotes = !inQuotes; }
        else if (char === delimiter && !inQuotes) { fields.push(current); current = ''; }
        else { current += char; }
      }
      fields.push(current);
    }
    while(fields.length < 5) fields.push('');
    state.stimuliPool.push({
      id: fields[0],
      text: fields[1],
      is_true: fields[2].toUpperCase() === 'TRUE',
      fact_check_true: fields[3],
      fact_check_false: fields[4]
    });
  });
  if(state.stimuliPool.length < CONFIG.numInductionTrials + CONFIG.numTestTrials) {
    throw new Error(`Insufficient stimuli loaded. Need ${CONFIG.numInductionTrials + CONFIG.numTestTrials}, found ${state.stimuliPool.length}.`);
  }
  shuffle(state.stimuliPool);
  state.inductionStatements = state.stimuliPool.slice(0, CONFIG.numInductionTrials);
  state.testStatements = state.stimuliPool.slice(CONFIG.numInductionTrials, CONFIG.numInductionTrials + CONFIG.numTestTrials);
}
async function preloadImages(list){ return Promise.resolve(); }

// ------------------- KEYBOARD HELPERS -------------------
function waitKeys(validKeys) {
  return new Promise(resolve => {
    function onKey(e) {
      const key = e.key.toLowerCase();
      if (validKeys.includes(key)) {
        document.removeEventListener('keydown', onKey);
        resolve(key);
      }
    }
    document.addEventListener('keydown', onKey);
  });
}
function waitKeysOrTimeout(validKeys, timeoutMs) {
  return new Promise(resolve => {
    let timeoutId = null;
    function onKey(e) {
      const key = e.key.toLowerCase();
      if (validKeys.includes(key)) {
        clearTimeout(timeoutId);
        document.removeEventListener('keydown', onKey);
        resolve({ key: key, timedOut: false });
      }
    }
    document.addEventListener('keydown', onKey);
    timeoutId = setTimeout(() => {
      document.removeEventListener('keydown', onKey);
      resolve({ key: null, timedOut: true });
    }, timeoutMs);
  });
}

// ------------------- FEEDBACK LOGIC -------------------
// SYMMETRIC NON-VERIDICAL SCHEDULE for INDUCTION:
// - p_c = CONFIG.feedbackManipulationPercentages[group] (Affirm if correct)
// - If correct: Affirm with p_c
// - If incorrect: Affirm with (1 - p_c)
// - Affirm shows a fact-check matching the participant's key (may be counterfactual)
// - Refute shows the opposite
// - content_alignment = 'veridical' iff shown fact-check aligns with ground truth
function chooseFeedback_nonVeridicalSymmetric(stimulus, participantResponse, group, answeredCorrectly){
  const p_c = CONFIG.feedbackManipulationPercentages[group]; // null for Control
  if (p_c == null) {
    // Control: veridical baseline
    const showTrue = stimulus.is_true;
    return {
      feedbackManipulationType: 'Veridical',
      feedbackShownFactCheckFor: showTrue,
      content_alignment: 'veridical'
    };
  }
  const p_i = 1 - p_c;
  const affirm = Math.random() < (answeredCorrectly ? p_c : p_i);

  // Affirm → fact-check SUPPORTS participant's key choice (True/False)
  const showTrueFactCheck = affirm
    ? (participantResponse === 'True')
    : !(participantResponse === 'True');

  const alignment = (showTrueFactCheck === stimulus.is_true) ? 'veridical' : 'counterfactual';

  return {
    feedbackManipulationType: affirm ? 'Affirm' : 'Refute',
    feedbackShownFactCheckFor: showTrueFactCheck,
    content_alignment: alignment
  };
}

// ------------------- INFO & CONSENT -------------------
async function showInformationAndConsent() {
  try {
    const response = await fetch('participant_information.txt');
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const infoHtml = await response.text();
    show(`
      <div class="info-container">
        ${infoHtml}
        <div class="button-container">
          <a href="PIS.pdf" download="PIS.pdf" target="_blank" rel="noopener noreferrer" style="text-decoration: none;"><button>Download Information Sheet (PDF)</button></a>
          <button id="next_btn">Next</button>
        </div>
      </div>
    `);
  } catch (e) {
    console.error('Failed to load participant information file:', e);
    show(`<p style="color:red;font-weight:bold;">Error: Could not load the participant information sheet.</p><p>Please contact the researcher.</p>`);
    return false;
  }
  await new Promise(resolve => { document.getElementById('next_btn').onclick = resolve; });

  show(`
    <div class="questionnaire-container">
      <p class="question-text">Are you over 18 years of age?</p>
      <button id="yes_btn">Yes</button> <button id="no_btn">No</button>
    </div>
  `);
  const isOver18 = await new Promise(resolve => {
    document.getElementById('yes_btn').onclick = () => resolve(true);
    document.getElementById('no_btn').onclick = () => resolve(false);
  });
  if (!isOver18) { exitToProlific('<p>You must be 18 or older to participate.</p>'); return false; }

  show(`
    <div class="questionnaire-container">
      <p class="question-text">Do you consent to participate in the study?</p>
      <button id="yes_btn">Yes</button> <button id="no_btn">No</button>
    </div>
  `);
  const hasConsented = await new Promise(resolve => {
    document.getElementById('yes_btn').onclick = () => resolve(true);
    document.getElementById('no_btn').onclick = () => resolve(false);
  });
  if (!hasConsented) { exitToProlific('<p>You did not consent to participate.</p>'); return false; }

  return true;
}

// ------------------- NEW: INELIGIBLE CSV LOADING -------------------
function parseIDsFromCSV(text) {
  const ids = new Set();
  if (!text || !text.trim()) return ids;

  const lines = text.replace(/\r/g, '\n').split('\n').map(s => s.trim()).filter(Boolean);
  if (!lines.length) return ids;

  // detect delimiter on header
  const headerLine = lines[0];
  const delim = headerLine.includes('\t') ? '\t' :
                headerLine.includes(',')  ? ','  :
                headerLine.includes(';')  ? ';'  : null;

  if (!delim) {
    // one ID per line
    lines.forEach(l => ids.add(normalizePID(l.replace(/^"|"$/g,''))));
    return ids;
  }

  const header = headerLine.split(delim).map(h => h.trim().toLowerCase());
  const pidColIndex =
    header.findIndex(h => /(prolific.*id|prolific_id|pid|participant.*id|participant)/i.test(h));

  // if we found a header with prolific/pid, use that column; else use first column
  const idx = pidColIndex >= 0 ? pidColIndex : 0;

  for (let i = 1; i < lines.length; i++) {
    const cols = lines[i].split(delim);
    if (cols[idx] != null && cols[idx].trim() !== '') {
      ids.add(normalizePID(cols[idx].replace(/^"|"$/g,'')));
    }
  }
  return ids;
}

async function loadIneligiblePIDSet() {
  try {
    const resp = await fetch(CONFIG.ineligibleCSV, { cache: 'no-store' });
    if (!resp.ok) throw new Error(`Failed to load ${CONFIG.ineligibleCSV}: ${resp.status} ${resp.statusText}`);
    const text = await resp.text();
    INELIGIBLE_SET = parseIDsFromCSV(text);
  } catch (e) {
    console.warn('Could not load ineligible CSV; proceeding without screening list.', e);
    INELIGIBLE_SET = new Set();
  }
}

function checkIneligibleAndMaybeRedirect(pid) {
  const norm = normalizePID(pid);
  if (INELIGIBLE_SET.has(norm)) {
    exitToProlific('<p>Our records show you have completed a similar study previously, so you are not eligible for this one.</p>');
    return true;
  }
  return false;
}

// ------------------- NEW: PROLIFIC ID GATE -------------------
async function showPIDGate() {
  // Try auto-capture from URL first
  const autoPID = getQueryPID();

  // Ensure we have the latest ineligible set before checking
  if (!INELIGIBLE_SET || INELIGIBLE_SET.size === 0) {
    await loadIneligiblePIDSet();
  }

  if (autoPID && autoPID.trim() !== '') {
    // Auto-screen
    state.participant = autoPID.trim();
    if (checkIneligibleAndMaybeRedirect(state.participant)) return;
    // Proceed to consent
    await afterPIDPassesGate();
    return;
  }

  // Manual entry UI
  show(`
    <h1>${CONFIG.experimentName}</h1>
    <p>Please enter your Prolific ID to begin.</p>
    <input id="pid" placeholder="Prolific ID" autocomplete="off" /><br>
    <button id="startBtn">Start</button>
  `);

  document.getElementById('startBtn').onclick = async () => {
    const pid = document.getElementById('pid').value.trim();
    if (!pid) { alert('Please enter a Prolific ID.'); return; }
    // Screen and proceed
    if (checkIneligibleAndMaybeRedirect(pid)) return;
    state.participant = pid;
    await afterPIDPassesGate();
  };
}

async function afterPIDPassesGate() {
  // Consent first (ethics), then load assets, then randomize group and continue
  const consentGiven = await showInformationAndConsent();
  if (!consentGiven) return;

  show('<h2>Loading experiment assets…</h2><p>This should only take a few seconds.</p>');
  await loadCSVStimuli();
  await preloadImages(state.stimuliPool);

  // Randomly assign group AFTER consent
  state.group = choice(CONFIG.groups);

  // Proceed to the rest of the flow (demographics -> instructions -> practice -> blocks ...)
  runDemographics();
}

// ------------------- CORE TRIAL LOGIC -------------------
async function runSingleTrial(stimulus, blockType, trialNumInBlock) {
  state.trialCountOverall++;
  show(`<div class="fixation-cross-container">+</div>`);
  await sleep(CONFIG.fixationCrossDuration);

  let leftInstruction, rightInstruction;
  if (state.keyMapping === 'q_true_p_false') {
    leftInstruction = 'Q = TRUE';
    rightInstruction = 'FALSE = P';
  } else {
    leftInstruction = 'Q = FALSE';
    rightInstruction = 'TRUE = P';
  }

  show(`
    <div class="statement-container">
      <div class="stimulus-text">${stimulus.text}</div>
      <div class="instructions-container">
        <span class="instruction-reminder">${leftInstruction}</span>
        <span class="instruction-reminder">${rightInstruction}</span>
      </div>
    </div>
  `);

  rtClock = performance.now();
  const responseResult = await waitKeysOrTimeout(['q', 'p'], CONFIG.statementTimeoutDuration);
  const rt = performance.now() - rtClock;
  let participantResponse = null;
  let isCorrect = null;
  let feedbackText = '';
  let feedbackManipulationType = '';
  let feedbackShownFactCheckFor = null;
  let contentAlignment = null;
  let keyPressed = responseResult.key;

  if (responseResult.timedOut) {
    participantResponse = 'TIMEOUT';
    isCorrect = null;
    feedbackText = "Please respond faster on the next trial.";
    feedbackManipulationType = 'TIMEOUT';
    show(`<div class="feedback-container"><p class="feedback-text">${feedbackText}</p></div>`);
    await sleep(CONFIG.timeoutFeedbackDuration);
  } else {
    if (state.keyMapping === 'q_true_p_false') {
      participantResponse = (keyPressed === 'q') ? 'True' : 'False';
    } else {
      participantResponse = (keyPressed === 'p') ? 'True' : 'False';
    }
    isCorrect = (participantResponse === 'True') === stimulus.is_true;

    if (blockType === 'ConfidenceInduction') {
      // Symmetric non-veridical schedule for High/Medium/Low; Control gets veridical.
      const fb = chooseFeedback_nonVeridicalSymmetric(stimulus, participantResponse, state.group, isCorrect);
      feedbackManipulationType  = fb.feedbackManipulationType;
      feedbackShownFactCheckFor = fb.feedbackShownFactCheckFor;
      contentAlignment          = fb.content_alignment;
    } else {
      // Test block: veridical (feedback not displayed for TruthTest, but we log it as veridical)
      feedbackManipulationType  = 'Veridical';
      feedbackShownFactCheckFor = stimulus.is_true;
      contentAlignment          = 'veridical';
    }

    feedbackText = feedbackShownFactCheckFor ? stimulus.fact_check_true : stimulus.fact_check_false;

    // Your original file suppresses visual feedback during TruthTest; we keep that behavior.
    if (blockType !== 'TruthTest') {
      show(`<div class="feedback-container"><p class="feedback-text">${feedbackText}</p></div>`);
      await sleep(CONFIG.feedbackDuration);
    }
  }

  const trialData = {
    pid: state.participant,
    session_key: state.sessionKey,
    group: state.group,
    block_type: blockType,
    trial_number_in_block: trialNumInBlock,
    trial_number_overall: state.trialCountOverall,
    statement_id: stimulus.id,
    statement_text: stimulus.text,
    statement_truth_value: stimulus.is_true ? 'TRUE' : 'FALSE',
    response: participantResponse,
    is_correct: isCorrect === null ? null : (isCorrect ? 1 : 0),
    rt_ms: responseResult.timedOut ? CONFIG.statementTimeoutDuration : Math.round(rt),
    key_mapping: state.keyMapping,
    key_pressed: keyPressed,
    feedback_manipulation_type: feedbackManipulationType,
    feedback_shown_fact_check_for: feedbackShownFactCheckFor === null ? null : (feedbackShownFactCheckFor ? 'TRUE_FACT_CHECK' : 'FALSE_FACT_CHECK'),
    content_alignment: contentAlignment
  };
  log(trialData);
  show('');
  await sleep(CONFIG.isiDuration);
}

// ------------------- DEMOGRAPHICS (unchanged) -------------------
async function runDemographics() {
  show(`
    <div class="questionnaire-container">
      <p class="question-text">Please enter your age:</p>
      <input type="number" id="q_input" min="1" autocomplete="off" />
      <button id="q_next">Next</button>
    </div>
  `);
  await new Promise(resolve => {
    document.getElementById('q_next').onclick = () => {
      const val = document.getElementById('q_input').value;
      if (val && !isNaN(parseInt(val, 10)) && parseInt(val, 10) > 0) {
        state.age = parseInt(val, 10);
        resolve();
      } else {
        alert('Please enter a valid number for your age.');
      }
    };
  });

  show(`
    <div class="questionnaire-container">
      <p class="question-text">Please select your gender:</p>
      <select id="q_input" autocomplete="off">
        <option value="" disabled selected>Select an option</option>
        <option value="male">Male</option>
        <option value="female">Female</option>
        <option value="non-binary">Non-binary</option>
        <option value="prefer-not-to-say">Prefer not to say</option>
        <option value="other">Other (please specify)</option>
      </select>
      <input type="text" id="q_other_text" style="display:none;" placeholder="Please specify" autocomplete="off" />
      <button id="q_next">Next</button>
    </div>
  `);
  const genderSelect = document.getElementById('q_input');
  const otherTextBox = document.getElementById('q_other_text');
  genderSelect.onchange = () => {
    if (genderSelect.value === 'other') otherTextBox.style.display = 'block';
    else otherTextBox.style.display = 'none';
  };
  await new Promise(resolve => {
    document.getElementById('q_next').onclick = () => {
      let val = genderSelect.value;
      if (val === 'other') val = `Other: ${otherTextBox.value.trim()}`;
      if (val && val !== '') { state.gender = val; resolve(); }
      else { alert('Please select an option.'); }
    };
  });

  show(`
    <div class="questionnaire-container">
      <p class="question-text">What is your highest level of education?</p>
      <select id="q_input" autocomplete="off">
        <option value="" disabled selected>Select an option</option>
        <option value="no-highschool">Did not complete highschool</option>
        <option value="highschool">Year 12 or equivalent</option>
        <option value="diploma">Diploma or equivalent</option>
        <option value="bachelors">Bachelor's degree or equivalent</option>
        <option value="postgrad">Post-graduate degree or equivalent (e.g., Master's or PhD)</option>
      </select>
      <button id="q_next">Next</button>
    </div>
  `);
  await new Promise(resolve => {
    document.getElementById('q_next').onclick = () => {
      const val = document.getElementById('q_input').value;
      if (val && val !== '') { state.education = val; resolve(); }
      else { alert('Please select an option.'); }
    };
  });

  showKeyMappingInstructions();
}

// ------------------- PRACTICE BLOCK (unchanged) -------------------
async function runPracticeBlock() {
  show(`
    <div class="info-container" style="text-align:center;">
      <h2>Practice Round</h2>
      <p>You will see some statements that have clear correct answers.</p>
      <p>This will help you get familiar with the response keys:</p>
      ${state.keyMapping === 'q_true_p_false' ? 
        '<p><b>Q = TRUE</b> and <b>P = FALSE</b></p>' : 
        '<p><b>P = TRUE</b> and <b>Q = FALSE</b></p>'}
      <p>Answer as <strong>quickly</strong> and as <strong>accurately</strong> as possible<p>
      <p>Press SPACE to begin the practice round.</p>
    </div>
  `);
  await waitKeys([' ']);

  for (let i = 0; i < practiceStatements.length; i++) {
    const stimulus = practiceStatements[i];
    show(`<div class="fixation-cross-container">+</div>`);
    await sleep(CONFIG.fixationCrossDuration);

    let leftInstruction, rightInstruction;
    if (state.keyMapping === 'q_true_p_false') {
      leftInstruction = 'Q = TRUE';
      rightInstruction = 'FALSE = P';
    } else {
      leftInstruction = 'Q = FALSE';
      rightInstruction = 'TRUE = P';
    }

    show(`
      <div class="statement-container">
        <div class="stimulus-text">${stimulus.text}</div>
        <div class="instructions-container">
          <span class="instruction-reminder">${leftInstruction}</span>
          <span class="instruction-reminder">${rightInstruction}</span>
        </div>
      </div>
    `);

    rtClock = performance.now();
    const responseResult = await waitKeysOrTimeout(['q', 'p'], CONFIG.statementTimeoutDuration);
    const rt = performance.now() - rtClock;
    let participantResponse = null;
    let keyPressed = responseResult.key;

    if (responseResult.timedOut) {
      participantResponse = 'TIMEOUT';
      show(`
        <div class="feedback-container">
          <p class="feedback-text">Time's up! Please try to respond faster.</p>
          <p>You have ${CONFIG.statementTimeoutDuration/1000} seconds to respond to each statement.</p>
          <p>Press SPACE to continue.</p>
        </div>
      `);
      await waitKeys([' ']);
    } else {
      if (state.keyMapping === 'q_true_p_false') {
        participantResponse = (keyPressed === 'q') ? 'True' : 'False';
      } else {
        participantResponse = (keyPressed === 'p') ? 'True' : 'False';
      }
      const feedbackText = (participantResponse === 'True') ? 
        stimulus.fact_check_true : stimulus.fact_check_false;
      show(`
        <div class="feedback-container">
          <p class="feedback-text">${feedbackText}</p>
          <p>Press SPACE to continue to the next practice question.</p>
        </div>
      `);
      await waitKeys([' ']);
    }
    show('');
    await sleep(CONFIG.isiDuration);
  }

  show(`
    <div class="info-container" style="text-align:center;">
      <h2>Practice Complete!</h2>
      <p>Now you will move on to the main task with news headlines.</p>
      <p>Remember:</p>
      ${state.keyMapping === 'q_true_p_false' ? 
        '<p><b>Q = TRUE</b> and <b>P = FALSE</b></p>' : 
        '<p><b>P = TRUE</b> and <b>Q = FALSE</b></p>'}
      <p>Answer as <strong>quickly</strong> and as <strong>accurately</strong> as possible<p>
      <p>Press SPACE to continue to the main task.</p>
    </div>
  `);
  await waitKeys([' ']);
  runBlock1();
}

// ------------------- KEY MAPPING INSTRUCTIONS (unchanged) -------------------
async function showKeyMappingInstructions() {
  state.keyMapping = (Math.random() < 0.5) ? 'q_true_p_false' : 'p_true_q_false';
  let keyInstructions = '';
  if (state.keyMapping === 'q_true_p_false') {
    keyInstructions = `Press the <b>Q</b> key for <b>TRUE</b>.<br>Press the <b>P</b> key for <b>FALSE</b>.`;
  } else {
    keyInstructions = `Press the <b>P</b> key for <b>TRUE</b>.<br>Press the <b>Q</b> key for <b>FALSE</b>.`;
  }

  const generalInstructions = `
    <div class="info-container" style="text-align:left; max-width: 720px;">
      <h2>Instructions</h2>
      <p>Welcome to this session. Please turn off your phone.</p>
      <p>Please read the following instructions carefully. They contain everything you need to know before we begin.</p>            
      <p>Throughout the task you will use your keyboard to respond. On each trial you will see <strong>one news claim</strong>. Some claims are accurate and others are not.</b></p>
      <p>Your task:</strong> press the key that corresponds to whether you believe the claim is <em>True</em> or <em>False</em>. Answer as <strong>quickly</strong> and as <strong>accurately</strong> as possible. Once an entry has been made, it is no longer possible to re-enter.</p>
      <hr style="margin: 2em 0;">
      <p style="font-size: 1.2em; text-align: center;">${keyInstructions}</p>
      <p>Place your fingers on the keys now. We will do a practice round first.</p>
      <p class="instructions" style="text-align: center; margin-top: 2em;">Press SPACE to proceed to the practice round.</p>
    </div>
  `;
  show(generalInstructions);
  await waitKeys([' ']);
  runPracticeBlock();
}

// ------------------- BLOCKS & QUESTIONNAIRES (unchanged) -------------------
async function runBlock1(){
  show(`<h2>Block 1</h2><p>Press SPACE to begin.</p>`);
  await waitKeys([' ']);
  for (let i = 0; i < state.inductionStatements.length; i++) {
    await runSingleTrial(state.inductionStatements[i], 'ConfidenceInduction', i + 1);
  }
  runQuestionnaire('pre');
}

async function runQuestionnaire(timing){
  const questions = [
    { id:'q_own_ability', text:"<br>How confident are you in your own ability to recognise news that is made up?<br>(1 = Not at all confident, 5 = Moderately confident, 9 = Extremely confident)", type:'number_1-9' },
    { id:'q_others_ability', text:"<br>How confident are you in others' ability to recognise news that is made up?<br>(1 = Not at all confident, 5 = Moderately confident, 9 = Extremely confident)", type:'number_1-9' },
    { id:'q_rank', text:"<br>On a scale from 0 % (no one) to 100 % (everyone), what percentage of people do you think you are better than at detecting news that is made up?<br>", type:'number_1-100' }
  ];
  for (const q of questions) {
    show(`
      <div class="questionnaire-container">
        <p class="question-text">${q.text}</p>
        ${q.type === 'number_1-100' ? '<input type="text" id="q_input" inputmode="numeric" pattern="\\d*" autocomplete="off" />' : ''}
        ${q.type === 'number_1-9' ? '<p class="instructions">Press a number key (1-9)</p>' : '<button id="q_next">Next</button>'}
      </div>
    `);
    let response;
    if (q.type === 'number_1-9') {
      const validKeys = ['1','2','3','4','5','6','7','8','9'];
      const key = await waitKeys(validKeys);
      response = parseInt(key);
    } else {
      await new Promise(resolve => {
        document.getElementById('q_next').onclick = () => {
          const val = parseInt(document.getElementById('q_input').value);
          if (val >= 1 && val <= 100) { response = val; resolve(); }
          else { alert('Please enter a number between 1 and 100.'); }
        };
      });
    }
    state[q.id + '_' + timing] = response;
  }
  if (timing === 'pre') runBlock2(); else runDebrief();
}

async function runBlock2(){
  show(`<h2>Block 2</h2><p>Press SPACE to begin.</p>`);
  await waitKeys([' ']);
  for (let i = 0; i < state.testStatements.length; i++) {
    await runSingleTrial(state.testStatements[i], 'TruthTest', i + 1);
  }
  runQuestionnaire('post');
}

// ------------------- DEBRIEF & FINISH (unchanged) -------------------
function downloadFactChecks() {
  const a = document.createElement('a');
  a.href = 'fact-checks.pdf';
  a.download = 'fact-checks.pdf';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
}

async function showDebriefing() {
  const group = state.group;
  let debriefFile = (group === 'Control') ? 'debrief_control.txt' : 'debrief_experimental.txt';
  try {
    const response = await fetch(debriefFile);
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const debriefHtml = await response.text();
    show(`
      <div class="debrief-container">
        ${debriefHtml}
        <div class="button-container">
          <button id="download_btn">Download All Fact-Checks</button>
          <button id="finish_btn">Finish Experiment</button>
        </div>
      </div>
    `);
    document.getElementById('download_btn').onclick = downloadFactChecks;
    document.getElementById('finish_btn').onclick = finishExperiment;
  } catch (e) {
    console.error('Failed to load debriefing file:', e);
    show(`
      <div class="questionnaire-container">
        <p style="color:red;font-weight:bold;">Error: Could not load the debriefing information.</p>
        <p>Please contact the researcher.</p>
        <p>You can still complete the experiment to receive payment.</p>
        <button id="finish_btn">Finish Experiment</button>
      </div>
    `);
    document.getElementById('finish_btn').onclick = finishExperiment;
  }
}

async function runDebrief() {
  show(`
    <div class="questionnaire-container">
      <p class="question-text">Did you respond randomly at any point during the study?</p>
      <p class="instructions">Note: Please be honest! You will get your payment regardless of your response.</p>
      <button id="yes_btn">Yes</button> <button id="no_btn">No</button>
    </div>
  `);
  state.responded_randomly = await new Promise(resolve => {
    document.getElementById('yes_btn').onclick = () => resolve('Yes');
    document.getElementById('no_btn').onclick = () => resolve('No');
  });

  show(`
    <div class="questionnaire-container">
      <p class="question-text">Did you search the internet (via Google or otherwise) for any of the news headlines?</p>
      <p class="instructions">Note: Please be honest! You will get your payment regardless of your response.</p>
      <button id="yes_btn">Yes</button> <button id="no_btn">No</button>
    </div>
  `);
  state.searched_internet = await new Promise(resolve => {
    document.getElementById('yes_btn').onclick = () => resolve('Yes');
    document.getElementById('no_btn').onclick = () => resolve('No');
  });

  showDebriefing();
}

function finishExperiment(){
  state.data.forEach(row => {
    row.q_own_ability_pre = state.q_own_ability_pre;
    row.q_others_ability_pre = state.q_others_ability_pre;
    row.q_rank_pre = state.q_rank_pre;
    row.q_own_ability_post = state.q_own_ability_post;
    row.q_others_ability_post = state.q_others_ability_post;
    row.q_rank_post = state.q_rank_post;
    row.age = state.age;
    row.gender = state.gender;
    row.education = state.education;
    row.responded_randomly = state.responded_randomly;
    row.searched_internet = state.searched_internet;
    if (!row.key_mapping) row.key_mapping = state.keyMapping;
  });

  const csv = toCSV(state.data);
  const fn  = `${CONFIG.experimentName}_${state.participant}_${state.group}_${Date.now()}.csv`;
  show('<h2>Uploading your data…</h2><p>Please wait. This should not take long.</p>');

  uploadCSV(fn,csv)
    .then(r=>{ if(!r.ok) throw new Error(`HTTP ${r.status} ${r.statusText}`); return r.json(); })
    .then(async () => { 
      show('<h2>Upload complete!</h2><p>Thank you for your participation. You will now be redirected back to Prolific.</p>'); 
      await sleep(3000);
      window.location.href = CONFIG.prolificCompletionURL;
    })
    .catch(err=>{
      console.error('Upload failed:',err);
      if(CONFIG.fallbackDownload){
        downloadFile(csv, fn, 'text/csv');
        show('<h2>Network error – data downloaded locally.</h2><p>Please ensure the downloaded CSV file is sent to the researcher. You may now close this window and return to Prolific.</p><p>Click here to return to Prolific: <a href="'+CONFIG.prolificCompletionURL+'">Complete Study</a></p>');
      }else{
        show('<h2>Sorry – data could not be saved.</h2><p>Please screenshot this page and contact the researcher. <br>Click here to return to Prolific: <a href="'+CONFIG.prolificCompletionURL+'">Complete Study</a></p>');
      }
    });
}

// ------------------- LAUNCH (CHANGED) -------------------
(async()=>{
  try{
    // 1) Prolific ID gate (auto-captures from URL or prompts)
    await showPIDGate();
    // Flow continues inside afterPIDPassesGate()
  }catch(e){
    console.error(e);
    show(`<p style="color:red;font-weight:bold;">Error: ${e.message}</p><p>Please check the browser console (Ctrl+Shift+J or Cmd+Opt+J) for more details and contact the researcher.</p>`);
  }
})();
</script>
</body>
</html>
